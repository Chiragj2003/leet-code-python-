"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    LeetCode #349 - Intersection of Two Arrays                 â•‘
â•‘                    Topic: Binary Search / Hash Set                           â•‘
â•‘                    Difficulty: Easy                                           â•‘
â•‘                    Company: Amazon, Meta, Apple                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ¯ QUESTION IN SIMPLE TERMS                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHAT'S THE PROBLEM?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Given two integer arrays, return array of their intersection.
Each element must appear UNIQUE (no duplicates in output).

EXAMPLES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Input: nums1 = [1,2,2,1], nums2 = [2,2] â†’ Output: [2]
âœ“ Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] â†’ Output: [9,4] or [4,9]

IMAGINE THIS (CHILD-FRIENDLY):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ¨ Paint colors: You have [red, blue, blue, red].
   Friend has [blue, blue]. Common color: [blue].

ğŸ§¸ Toys: Your toys [car, doll, doll, car].
   Friend's toys [doll, doll]. Shared: [doll].

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â­ AMAZON STAR METHOD ANSWER                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Œ SITUATION:
   Amazon recommendations: find products viewed by both users.

ğŸ“Œ TASK:
   Find unique intersection of two arrays.
   Time O(n+m), Space O(min(n,m)).

ğŸ“Œ ACTION:
   Hash set approach:
   1. Put smaller array in set
   2. Check each element of larger array
   3. Add to result if in set

ğŸ“Œ RESULT:
   âœ“ Time: O(n + m) linear
   âœ“ Space: O(min(n,m)) for set
   âœ“ Fast common element finding

"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¡ BRUTE FORCE - Nested Loop
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def intersection_bruteforce(nums1, nums2):
    """
    Check each pair
    
    Time: O(n Ã— m)
    Space: O(1) excluding result
    """
    result = set()
    
    for num1 in nums1:
        for num2 in nums2:
            if num1 == num2:
                result.add(num1)
                break
    
    return list(result)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ OPTIMAL SOLUTION - Hash Set
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def intersection(nums1, nums2):
    """
    Hash set for O(1) lookups
    
    Example: [1,2,2,1] and [2,2]
    â”€â”€â”€â”€â”€â”€â”€â”€
    set1 = {1, 2}
    Check each in nums2:
    - 2 in set1? Yes â†’ add to result
    - 2 in set1? Yes (but already in result)
    Result: [2]
    """
    set1 = set(nums1)
    result = set()
    
    for num in nums2:
        if num in set1:
            result.add(num)
    
    return list(result)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“š ALTERNATIVE - Binary Search
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def intersection_binary(nums1, nums2):
    """
    Binary search approach (if arrays sorted)
    
    Time: O(n log n + m log m) for sorting + O(n log m)
    Space: O(1) excluding result
    """
    nums1.sort()
    nums2.sort()
    result = set()
    
    def binary_search(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return True
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return False
    
    # Search for each nums1 element in nums2
    for num in nums1:
        if binary_search(nums2, num):
            result.add(num)
    
    return list(result)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ ALTERNATIVE - Two Pointers (for sorted arrays)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def intersection_twopointer(nums1, nums2):
    """
    Two pointers on sorted arrays
    
    Time: O(n log n + m log m + n + m)
    Space: O(1) excluding result
    """
    nums1.sort()
    nums2.sort()
    
    i = j = 0
    result = set()
    
    while i < len(nums1) and j < len(nums2):
        if nums1[i] == nums2[j]:
            result.add(nums1[i])
            i += 1
            j += 1
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1
    
    return list(result)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š COMPLEXITY COMPARISON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   Approach     â•‘      Time      â•‘   Space   â•‘       Notes             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Brute Force    â•‘    O(nÃ—m)      â•‘   O(1)    â•‘ Nested loops            â•‘
â•‘ Hash Set       â•‘    O(n+m)      â•‘ O(min(n,m))â•‘ Best for unsorted       â•‘
â•‘ Binary Search  â•‘O(n log m+sort) â•‘   O(1)    â•‘ Good if sorted          â•‘
â•‘ Two Pointers   â•‘  O(n+m+sort)   â•‘   O(1)    â•‘ Clean if sorted         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§ª TEST CASES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    test_cases = [
        ([1, 2, 2, 1], [2, 2]),
        ([4, 9, 5], [9, 4, 9, 8, 4]),
        ([1, 2, 3], [4, 5, 6]),
    ]
    
    print("=" * 70)
    print("ğŸ§ª TESTING INTERSECTION OF TWO ARRAYS")
    print("=" * 70)
    
    for nums1, nums2 in test_cases:
        brute = sorted(intersection_bruteforce(nums1.copy(), nums2.copy()))
        optimal = sorted(intersection(nums1.copy(), nums2.copy()))
        binary = sorted(intersection_binary(nums1.copy(), nums2.copy()))
        twoptr = sorted(intersection_twopointer(nums1.copy(), nums2.copy()))
        
        print(f"\nInput: nums1 = {nums1}, nums2 = {nums2}")
        print(f"Brute: {brute}")
        print(f"Hash Set: {optimal}")
        print(f"Binary: {binary}")
        print(f"Two Pointer: {twoptr}")
