"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    LeetCode #300 - Longest Increasing Subsequence             â•‘
â•‘                    Topic: Dynamic Programming                                â•‘
â•‘                    Difficulty: Medium                                         â•‘
â•‘                    Company: Amazon, Microsoft, Meta                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ¯ QUESTION IN SIMPLE TERMS                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHAT'S THE PROBLEM?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Find length of longest strictly increasing subsequence.
Subsequence: maintain relative order, don't need consecutive.

EXAMPLES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Input: [10,9,2,5,3,7,101,18] â†’ Output: 4
  Subsequence: [2,3,7,101] or [2,5,7,101]

âœ“ Input: [0,1,0,3,2,3] â†’ Output: 4
  Subsequence: [0,1,2,3]

âœ“ Input: [7,7,7,7] â†’ Output: 1

IMAGINE THIS (CHILD-FRIENDLY):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ˆ Stock prices: [10,9,2,5,3,7,101,18]
   Find longest period of increasing prices.
   Days 3â†’5â†’8 (prices 2â†’5â†’7â†’101) = 4 days!

ğŸ¯ High scores: Select games where score keeps increasing.
   [2,5,7,101] increases continuously!

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â­ AMAZON STAR METHOD ANSWER                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Œ SITUATION:
   Amazon metrics: find longest streak of improving
   performance metrics over time.

ğŸ“Œ TASK:
   Find length of longest increasing subsequence.
   Time O(nÂ²) DP or O(n log n) binary search.

ğŸ“Œ ACTION:
   DP approach:
   - dp[i] = length of LIS ending at i
   - Check all previous elements

ğŸ“Œ RESULT:
   âœ“ Time: O(nÂ²) DP or O(n log n) optimized
   âœ“ Space: O(n)
   âœ“ Longest sequence found

"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ’¡ BRUTE FORCE - Try All Subsequences
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def lengthOfLIS_bruteforce(nums):
    """
    Generate all subsequences, check which are increasing
    
    Time: O(2^n) - exponential!
    Space: O(n)
    """
    def lis(index, prev):
        if index == len(nums):
            return 0
        
        # Skip current
        skip = lis(index + 1, prev)
        
        # Take current if valid
        take = 0
        if prev == -1 or nums[index] > nums[prev]:
            take = 1 + lis(index + 1, index)
        
        return max(skip, take)
    
    return lis(0, -1)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“š BETTER - Dynamic Programming O(nÂ²)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def lengthOfLIS(nums):
    """
    Bottom-up DP
    
    dp[i] = length of LIS ending at index i
    
    Example: [10,9,2,5,3,7,101,18]
    â”€â”€â”€â”€â”€â”€â”€â”€
    dp[0] = 1 (just 10)
    dp[1] = 1 (just 9, can't extend from 10)
    dp[2] = 1 (just 2)
    dp[3] = 2 (2â†’5)
    dp[4] = 2 (2â†’3)
    dp[5] = 3 (2â†’3â†’7 or 2â†’5â†’7)
    dp[6] = 4 (2â†’3â†’7â†’101 or 2â†’5â†’7â†’101)
    dp[7] = 4 (2â†’3â†’7â†’18)
    
    Max = 4
    """
    if not nums:
        return 0
    
    n = len(nums)
    dp = [1] * n  # Each element is LIS of length 1
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ OPTIMAL SOLUTION - Binary Search O(n log n)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def lengthOfLIS_optimal(nums):
    """
    Binary search approach
    
    Maintain array of smallest tail values for each length
    
    Time: O(n log n)
    Space: O(n)
    """
    import bisect
    
    tails = []
    
    for num in nums:
        # Find position to insert/replace
        pos = bisect.bisect_left(tails, num)
        
        if pos == len(tails):
            tails.append(num)
        else:
            tails[pos] = num
    
    return len(tails)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š COMPLEXITY COMPARISON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   Approach     â•‘    Time    â•‘   Space   â•‘       Notes             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Brute Force    â•‘   O(2^n)   â•‘   O(n)    â•‘ Try all subsequences    â•‘
â•‘ DP             â•‘   O(nÂ²)    â•‘   O(n)    â•‘ Standard solution       â•‘
â•‘ Binary Search  â•‘ O(n log n) â•‘   O(n)    â•‘ Optimal                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§ª TEST CASES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    test_cases = [
        ([10, 9, 2, 5, 3, 7, 101, 18], 4),
        ([0, 1, 0, 3, 2, 3], 4),
        ([7, 7, 7, 7, 7, 7, 7], 1),
    ]
    
    print("=" * 70)
    print("ğŸ§ª TESTING LONGEST INCREASING SUBSEQUENCE")
    print("=" * 70)
    
    for nums, expected in test_cases:
        brute = lengthOfLIS_bruteforce(nums) if len(nums) < 15 else "Skipped"
        dp = lengthOfLIS(nums)
        optimal = lengthOfLIS_optimal(nums)
        
        print(f"\nInput: {nums}")
        print(f"Expected: {expected}")
        print(f"Brute: {brute}")
        print(f"DP O(nÂ²): {dp} {'âœ“' if dp == expected else 'âœ—'}")
        print(f"Binary O(n log n): {optimal} {'âœ“' if optimal == expected else 'âœ—'}")
